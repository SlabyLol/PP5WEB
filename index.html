<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Poppy Playtime Ch. 5 - Pro Remake</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nosifer&family=Oswald:wght@700&display=swap');
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
        
        /* STARTMENÜ */
        #menu-overlay {
            position: absolute; inset: 0; display: flex; justify-content: center; align-items: center;
            background: radial-gradient(circle, #200 0%, #000 90%); z-index: 1000; transition: 1s;
        }
        .menu-box { text-align: center; font-family: 'Oswald'; color: white; }
        h1 { font-family: 'Nosifer'; color: #f00; font-size: 3rem; margin: 0; text-shadow: 0 0 20px #f00; }

        /* MOBILE UI */
        #mobile-ui { position: absolute; inset: 0; pointer-events: none; z-index: 100; display: none; }
        .joystick-zone {
            position: absolute; bottom: 30px; width: 120px; height: 120px;
            background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%; pointer-events: auto;
        }
        #joy-move { left: 30px; } /* Linker Joystick */
        #joy-look { right: 30px; } /* Rechter Joystick */
        .knob {
            position: absolute; top: 35px; left: 35px; width: 50px; height: 50px;
            background: rgba(255,255,255,0.3); border-radius: 50%;
        }
        .action-btns { position: absolute; bottom: 170px; right: 30px; display: flex; flex-direction: column; gap: 15px; pointer-events: auto; }
        .h-btn { width: 60px; height: 60px; border-radius: 10px; border: 3px solid #000; }
        #b-blue { background: #0088ff; } #b-red { background: #ff0000; }

        #info-text { position: absolute; top: 20px; width: 100%; text-align: center; color: #ff0000; font-family: 'Oswald'; z-index: 100; font-size: 1.2rem; }
    </style>
</head>
<body>

    <div id="menu-overlay">
        <div class="menu-box">
            <h1>POPPY PLAYTIME</h1>
            <p>CHAPTER 5: THE REMAKE</p>
            <button style="padding:15px 40px; font-size:1.5rem; cursor:pointer;" onclick="start('PC')">PC START</button>
            <button style="padding:15px 40px; font-size:1.5rem; cursor:pointer;" onclick="start('Mobile')">MOBILE START</button>
        </div>
    </div>

    <div id="info-text">FINDE DEN HAND-SCANNER</div>

    <div id="mobile-ui">
        <div id="joy-move" class="joystick-zone"><div class="knob" id="knob-move"></div></div>
        <div id="joy-look" class="joystick-zone"><div class="knob" id="knob-look"></div></div>
        <div class="action-btns">
            <div id="b-blue" class="h-btn" onpointerdown="shoot('blue')"></div>
            <div id="b-red" class="h-btn" onpointerdown="shoot('red')"></div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let active = false, mode = 'PC';
        let moveVec = { x: 0, y: 0 }, lookVec = { x: 0, y: 0 };
        let rotation = { lat: 0, lon: -90 };
        const walls = [];

        // Scene
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.12);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Licht
        const flashlight = new THREE.SpotLight(0xffffff, 80, 25, 0.4, 0.2);
        camera.add(flashlight);
        flashlight.position.set(0,0,0.1);
        flashlight.target.position.set(0,0,-1);
        camera.add(flashlight.target);
        scene.add(camera);

        // Welt Bauen (Kollisionen)
        const addWall = (w, h, d, x, y, z) => {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color: 0x111111}));
            mesh.position.set(x,y,z);
            scene.add(mesh);
            walls.push(new THREE.Box3().setFromObject(mesh));
        };

        // Boden
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({color: 0x0a0a0a}));
        floor.rotation.x = -Math.PI/2;
        scene.add(floor);

        // Der Level-Gang
        addWall(1, 6, 40, 5, 3, -15);  // Rechts
        addWall(1, 6, 40, -5, 3, -15); // Links
        addWall(10, 6, 1, 0, 3, -35); // Ende

        // Interaktive Objekte
        const boxGeo = new THREE.BoxGeometry(1.5,1.5,1.5);
        const pullable = new THREE.Mesh(boxGeo, new THREE.MeshStandardMaterial({color: 0xffcc00}));
        pullable.position.set(0, 0.75, -10);
        scene.add(pullable);
        let pullableBound = new THREE.Box3().setFromObject(pullable);

        const terminal = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.2), new THREE.MeshStandardMaterial({color: 0x0044ff}));
        terminal.position.set(4.4, 1.5, -8);
        scene.add(terminal);

        // GrabPack
        const hB = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.2,0.4), new THREE.MeshStandardMaterial({color:0x0088ff}));
        const hR = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.2,0.4), new THREE.MeshStandardMaterial({color:0xff0000}));
        camera.add(hB); camera.add(hR);
        hB.position.set(-0.6,-0.4,-0.8); hR.position.set(0.6,-0.4,-0.8);

        // Steuerung Mobile Joysticks
        const setupJoystick = (id, knobId, callback) => {
            const zone = document.getElementById(id);
            const knob = document.getElementById(knobId);
            zone.onpointermove = (e) => {
                const rect = zone.getBoundingClientRect();
                const dx = (e.clientX - rect.left - 60) / 60;
                const dy = (e.clientY - rect.top - 60) / 60;
                knob.style.transform = `translate(${dx*30}px, ${dy*30}px)`;
                callback(dx, dy);
            };
            zone.onpointerup = () => {
                knob.style.transform = `translate(0,0)`;
                callback(0, 0);
            };
        };

        setupJoystick('joy-move', 'knob-move', (x, y) => { moveVec = { x, y }; });
        setupJoystick('joy-look', 'knob-look', (x, y) => { lookVec = { x, y }; });

        // Spielstart
        window.start = (m) => {
            mode = m; active = true;
            document.getElementById('menu-overlay').style.opacity = 0;
            if(mode === 'Mobile') document.getElementById('mobile-ui').style.display = 'block';
            else renderer.domElement.requestPointerLock();
            setTimeout(() => document.getElementById('menu-overlay').style.display = 'none', 1000);
        };

        // Mechanik: Schießen & Ziehen
        window.shoot = (side) => {
            const hand = side === 'blue' ? hB : hR;
            hand.position.z = -8;
            
            const ray = new THREE.Raycaster();
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            ray.set(camera.position, dir);
            const hits = ray.intersectObjects(scene.children);

            if(hits.length > 0) {
                const obj = hits[0].object;
                if(obj === pullable) {
                    pullable.position.add(dir.multiplyScalar(-2)); // Block wird gezogen
                    pullable.position.y = 0.75; // Bleibt am Boden
                }
                if(obj === terminal && side === 'blue') {
                    terminal.material.color.set(0x00ff00);
                    document.getElementById('info-text').innerText = "ZUGANG GEWÄHRT!";
                }
            }
            setTimeout(() => hand.position.z = -0.8, 300);
        };

        // Keyboard für PC
        let keys = {};
        window.onkeydown = (e) => keys[e.code] = true;
        window.onkeyup = (e) => keys[e.code] = false;
        window.onmousedown = (e) => { if(active && mode === 'PC') shoot(e.button === 0 ? 'blue' : 'red'); };

        // Game Loop
        function update() {
            requestAnimationFrame(update);
            if(!active) return;

            // Umschauen (Joystick oder Maus)
            if(mode === 'Mobile') {
                rotation.lon += lookVec.x * 2;
                rotation.lat -= lookVec.y * 2;
            } else {
                window.onmousemove = (e) => {
                    if(document.pointerLockElement) {
                        rotation.lon += e.movementX * 0.1;
                        rotation.lat -= e.movementY * 0.1;
                    }
                };
            }

            rotation.lat = Math.max(-85, Math.min(85, rotation.lat));
            const phi = THREE.MathUtils.degToRad(90 - rotation.lat);
            const theta = THREE.MathUtils.degToRad(rotation.lon);
            const target = new THREE.Vector3().setFromSphericalCoords(1, phi, theta).add(camera.position);
            camera.lookAt(target);

            // Bewegung & Kollision
            const oldPos = camera.position.clone();
            const speed = 0.12;
            
            if(keys['KeyW']) camera.translateZ(-speed);
            if(keys['KeyS']) camera.translateZ(speed);
            if(keys['KeyA']) camera.translateX(-speed);
            if(keys['KeyD']) camera.translateX(speed);
            
            if(mode === 'Mobile') {
                camera.translateZ(moveVec.y * speed);
                camera.translateX(moveVec.x * speed);
            }

            camera.position.y = 1.6;

            // Kollisions-Check gegen Wände & Block
            const playerBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(0.8, 2, 0.8));
            pullableBound.setFromObject(pullable);
            
            let collision = false;
            walls.forEach(wall => { if(playerBox.intersectsBox(wall)) collision = true; });
            if(playerBox.intersectsBox(pullableBound)) collision = true;

            if(collision) camera.position.copy(oldPos); // Bei Kollision zurücksetzen

            renderer.render(scene, camera);
        }
        update();
    </script>
</body>
</html>
